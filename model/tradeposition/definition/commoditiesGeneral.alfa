namespace ALFABANK.Regulatory.Model

# Section 2j - Commodities and emission allowances (General) derivative
record CommoditiesGeneral includes DerivativesTradeReport {
    /# **Field 2.116** 
       Base product as specified in the classification of commodities in Table 4 of Annex I of the [ITS].#/
    @FieldClassification(Classification=FieldClassificationType.Other)
    baseProduct : BaseProductType

    /# **Field 2.117**
       Subproduct as specified in the classification of commodities in Table 4 of Annex I of the [ITS]
       This field requires a specific base product in field.#/
    @FieldClassification(Classification=FieldClassificationType.Other)   
    subProduct : SubProductType

    /# **Field 2.118** 
       Further-sub-product as specified in the classification of commodities in Table 4 of Annex I of the [ITS]
       This field requires a specific base product in field.#/
    @FieldClassification(Classification=FieldClassificationType.Other)   
    furtherSubProduct : FurtherSubProductType
}

fragment record CommoditiesGeneral {
    # Re-usable rule to **validate classification of commodities** as per Table 4 of Annex I of the  ITS
    assert CheckClassificationHierarchy {

        # Build a hierarchy of baseProduct - > subProduct - > furtherSubProduct based on the enum naming 
        let hierarchy : map< string, map< string, set< string  > > > =
                toMap( toList(enumValues( BaseProductType )),
                       k1 => k1,
                       k1 => toMap< map< string, set< string  > > >( toList(enumValues( "Model." + k1 + "_SubProductType", ( list<string> ) [] )),
                                    k2 => k2,
                                    k2 => enumValues( "Model." + k1 + "_" + k2 + "_FurtherSubProductType", ( list<string> ) [] )
                                  )
                     )

        # Use hierachy to get the sub-products for the given base-product
         let subProdsMap =get ( get( hierarchy, toString( baseProduct ) ) )

         # Check if the sub-product is defined under the base product 
         if ( ! contains( keys( subProdsMap ), toString(subProduct) ) )
             # Warning: sub-product is not one that is valid under the base-product
             raise warning("EMIR-VR-NNN, 'Invalid sub-product ${subProduct} for base type ${baseProduct}' ")

        
        # Use hierachy to get the further-sub-products for the given sub-product
         let furtherSubProdsSet =get( get( subProdsMap, toString( furtherSubProduct ) ) )

         # Check if the sub-product is defined under the further-sub-product 
         if ( ! contains( furtherSubProdsSet, toString(furtherSubProduct) ) )
             # Warning: further-sub-product is not one that is valid under the sub-product
             raise warning("EMIR-VR-NNN, 'Invalid further-sub-product ${furtherSubProduct} for sub product ${baseProduct}' ")
    }
}
